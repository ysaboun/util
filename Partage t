### ğŸ“Œ **Comment partager un token entre deux Service Workers distincts sur** `www.site.fr` **et** `www.sous-domaine.site.fr` ?  

Un **Service Worker est isolÃ© par origine** (`origin` = **protocole + domaine + port**). Donc, un Service Worker enregistrÃ© sur `www.site.fr` ne peut **pas** directement accÃ©der aux donnÃ©es dâ€™un Service Worker sur `www.sous-domaine.site.fr`.  

ğŸ”¹ **ProblÃ¨me :**  
Si `www.site.fr` et `www.sous-domaine.site.fr` ont **chacun leur propre Service Worker**, ils **ne peuvent pas directement communiquer** ou partager un stockage commun.  

ğŸ”¹ **Solutions possibles :**  
1. **Utiliser un serveur centralisÃ© pour rÃ©cupÃ©rer le token** âœ… (RecommandÃ©)  
2. **Partager le token via un cookie (`Domain=site.fr`)**  
3. **Utiliser un iframe + `postMessage()` pour Ã©changer les tokens**  
4. **Utiliser BroadcastChannel API** (si mÃªme top-level domain)  

---

## 1ï¸âƒ£ **Solution recommandÃ©e : Une API backend pour centraliser les tokens**  
#### âœ… Avantages :  
- **SÃ©curisÃ©** (pas dâ€™exposition du token en local).  
- **Facile Ã  gÃ©rer** cÃ´tÃ© backend.  
- Compatible avec tous les navigateurs.  

#### âŒ InconvÃ©nients :  
- NÃ©cessite un backend/API.  
- Chaque Service Worker doit faire une requÃªte API pour rÃ©cupÃ©rer le token.  

### ğŸ”¹ **Comment faire ?**
1. Lorsqu'un utilisateur s'authentifie sur **`www.site.fr`**, le token est **stockÃ© cÃ´tÃ© serveur**.
2. Le Service Worker de **`www.site.fr`** et celui de **`www.sous-domaine.site.fr`** font une requÃªte API pour rÃ©cupÃ©rer le token lorsquâ€™ils en ont besoin.  

### **Exemple :**  
Dans `www.site.fr/sw.js` et `www.sous-domaine.site.fr/sw.js` :
```js
self.addEventListener("fetch", async (event) => {
  if (event.request.url.includes("/api/protected-resource")) {
    event.respondWith(
      fetchWithToken(event.request)
    );
  }
});

async function fetchWithToken(request) {
  let token = await getTokenFromServer();
  let modifiedHeaders = new Headers(request.headers);
  modifiedHeaders.set("Authorization", `Bearer ${token}`);

  let modifiedRequest = new Request(request, {
    headers: modifiedHeaders,
  });

  return fetch(modifiedRequest);
}

async function getTokenFromServer() {
  const response = await fetch("https://api.site.fr/get-token", {
    credentials: "include",
  });
  const data = await response.json();
  return data.token;
}
```

Dans `api.site.fr` (Backend) :
```js
app.get("/get-token", (req, res) => {
  const userSession = getUserSession(req);
  if (userSession) {
    res.json({ token: userSession.token });
  } else {
    res.status(401).json({ error: "Unauthorized" });
  }
});
```

**ğŸ‘‰ Avantage :** Chaque Service Worker peut rÃ©cupÃ©rer le token **de maniÃ¨re sÃ©curisÃ©e** sans stockage local.  

---

## 2ï¸âƒ£ **Utiliser un cookie avec `Domain=site.fr`**  
#### âœ… Avantages :  
- **Simple Ã  implÃ©menter**.  
- Accessible par `www.site.fr` **et** `www.sous-domaine.site.fr`.  
- Fonctionne mÃªme si JavaScript est dÃ©sactivÃ©.  

#### âŒ InconvÃ©nients :  
- **Moins sÃ©curisÃ©** (exposÃ© aux attaques CSRF).  
- **Pas accessible directement par les Service Workers** (mais peut Ãªtre rÃ©cupÃ©rÃ© via une requÃªte `fetch()`).  

### ğŸ”¹ **Comment faire ?**  
1. **Stocker le token dans un cookie sÃ©curisÃ©** sur `site.fr` :  
```js
document.cookie = "token=xxxx; Path=/; Domain=site.fr; Secure; HttpOnly";
```
2. **Les Service Workers sur `www.site.fr` et `www.sous-domaine.site.fr` font une requÃªte pour rÃ©cupÃ©rer le cookie :**  
```js
async function getTokenFromCookie() {
  const response = await fetch("/get-token-from-cookie", {
    credentials: "include",
  });
  const data = await response.json();
  return data.token;
}
```

**ğŸ‘‰ Limite :** Le Service Worker **ne peut pas directement lire** les cookies, donc il faut une API ou une requÃªte client.  

---

## 3ï¸âƒ£ **Utiliser un iframe + `postMessage()`**  
#### âœ… Avantages :  
- **Compatible avec toutes les plateformes**.  
- Fonctionne sans backend si un domaine central est disponible.  

#### âŒ InconvÃ©nients :  
- **Complexe Ã  mettre en place**.  
- **DÃ©pend dâ€™un domaine partagÃ©** (`auth-proxy.site.fr`).  

### ğŸ”¹ **Comment faire ?**  
1. **CrÃ©er un iframe sur un domaine centralisÃ© (`auth-proxy.site.fr`) qui stocke le token en `localStorage`.**  
2. Les Service Workers de `www.site.fr` et `www.sous-domaine.site.fr` communiquent avec cet iframe via `postMessage()`.  

**Dans `auth-proxy.site.fr/index.html` :**  
```js
window.addEventListener("message", (event) => {
  if (event.origin.endsWith(".site.fr")) {  
    event.source.postMessage({ token: localStorage.getItem("token") }, event.origin);
  }
});
```

**Dans `www.site.fr` et `www.sous-domaine.site.fr` :**  
```js
const iframe = document.createElement("iframe");
iframe.src = "https://auth-proxy.site.fr";
document.body.appendChild(iframe);

window.addEventListener("message", (event) => {
  if (event.origin === "https://auth-proxy.site.fr") {
    const token = event.data.token;
    console.log("Token reÃ§u :", token);
  }
});

iframe.onload = () => {
  iframe.contentWindow.postMessage({ action: "getToken" }, "https://auth-proxy.site.fr");
};
```

**ğŸ‘‰ Limite :** NÃ©cessite un **iframe visible ou cachÃ©**, ce qui peut ne pas Ãªtre optimal.  

---

## 4ï¸âƒ£ **Utiliser `BroadcastChannel API` (si mÃªme domaine racine)**  
#### âœ… Avantages :  
- **Simple et efficace** si les deux sites partagent le mÃªme **top-level domain** (`site.fr`).  
- Permet une **communication directe** entre les deux Service Workers.  

#### âŒ InconvÃ©nients :  
- **Ne fonctionne pas si les origines sont diffÃ©rentes** (ex. `www.site.fr` et `api.site.fr`).  

### ğŸ”¹ **Comment faire ?**  
Dans `www.site.fr/sw.js` et `www.sous-domaine.site.fr/sw.js` :  
```js
const channel = new BroadcastChannel("auth-channel");

channel.addEventListener("message", (event) => {
  console.log("Token reÃ§u :", event.data.token);
});

// Envoyer un token
channel.postMessage({ token: "mon-token" });
```

**ğŸ‘‰ Limite :** Ne fonctionne **que si les pages sont dÃ©jÃ  ouvertes** dans le navigateur.  

---

## ğŸš€ **Quelle solution choisir ?**
| **MÃ©thode** | **SÃ©curitÃ©** | **ComplexitÃ©** | **Performance** | **Cas dâ€™usage** |
|------------|-------------|----------------|-----------------|----------------|
| **API centralisÃ©e** | âœ…âœ… TrÃ¨s sÃ©curisÃ© | âš ï¸ NÃ©cessite un backend | ğŸš€ Performant | RecommandÃ© pour production |
| **Cookies (`Domain=site.fr`)** | âš ï¸ Moins sÃ©curisÃ© (CSRF) | âœ… Simple | ğŸš€ Rapide | Sites simples, sans besoin de haute sÃ©curitÃ© |
| **Iframe + `postMessage()`** | âœ… SÃ©curisÃ© | âš ï¸ Complexe | ğŸš€ Performant | Apps SPA nÃ©cessitant du localStorage partagÃ© |
| **BroadcastChannel API** | âœ… SÃ©curisÃ© | âœ… Simple | ğŸš€ TrÃ¨s rapide | Fonctionne uniquement sur le mÃªme domaine racine |

### **ğŸ† Meilleure option pour la sÃ©curitÃ© et la scalabilitÃ© :**
**ğŸ‘‰ Utiliser une API backend centralisÃ©e (`api.site.fr`).**  

Tu veux une implÃ©mentation spÃ©cifique ?
