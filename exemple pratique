Voici un **sch√©ma textuel en Markdown** d√©crivant **les √©tapes haut niveau de votre filtre POC (`PocFilter`)**. Ce sch√©ma r√©sume l‚Äô**architecture globale** et les **√©tapes principales** du traitement des requ√™tes HTTP dans votre filtre.

---

## üõ°Ô∏è Sch√©ma haut niveau ‚Äî `PocFilter` (Architecture fonctionnelle)

```markdown
graph TD
  A[Entr√©e requ√™te HTTP] --> B[Logging (FilterLogHandler.prepareLogging)]
  B --> C[Validation requ√™te (ApiRequestFilter.run)]

  C -->|Requ√™te "trusted" ou d√©j√† valid√©e| D[Bypass traitement ‚Äî doContinue=true]

  C -->|Requ√™te √† traiter| E[Handle Request (RequestHandler)]
  E --> F[Update ValidateResponse.doContinue = true]

  D --> G[Passage au reste du filtre - FilterChain.doFilter()]
  F --> G

  G --> H[R√©ponse HTTP intercept√©e (ContentCachingResponseWrapper)]
  H --> I[Analyse et enrichissement de r√©ponse (ResponseFilter.run)]

  I -->|Succ√®s| J[R√©ponse HTTP vers client]
  I -->|Erreur| K[ResponseToClient.sendError()]

  J --> L[Fin traitement ‚Äî MDC.clear()]
  K --> L
```

---

## üß© √âtapes d√©taill√©es (Vue d√©veloppeur)

1. **Initialisation du filtre (`PocFilter`)**

   * `initFilterBean()` : mappe les `handlers` pour `request` et `response`.

2. **Filtrage conditionnel (`shouldNotFilter`)**

   * √âvite d'intercepter les requ√™tes hors p√©rim√®tre (`uriToFilter`).

3. **Entr√©e dans `doFilterInternal`**

   * Logging du `requestId` (`FilterLogHandler`).
   * Ex√©cution de `ApiRequestFilter.run()` :

     * **Si URI "trusted"** ‚Üí on bypass `handleRequest`, `doContinue=true`.
     * Sinon, parsing et validation compl√®te :

       * Headers obligatoires (`requiredHeaders`)
       * URI match (`authorizedUri`)
       * Corps requis (pour POST/PUT)
       * Type de requ√™te (via `REQUEST_TYPES`)
       * Construction de `ApiRequest`

4. **Traitement m√©tier de la requ√™te**

   * `RequestHandler.handleXRequest()` selon le type d√©tect√© (`ACCOUNTS_REQUEST`, `EVENT_REQUEST`)
   * Enrichit la requ√™te avec un `BusinessRequest`
   * Marque `doContinue=true`

5. **Transmission √† la cha√Æne de filtres (`filterChain.doFilter`)**

   * Utilise un `ContentCachingResponseWrapper` pour capturer la r√©ponse.

6. **Traitement de la r√©ponse HTTP**

   * `ResponseFilter.run()` :

     * Capture `payload` de r√©ponse
     * Appelle le `ResponseHandler.handleXResponse()`
     * Ajoute les headers de tracing (`x-request-id`, etc.)
     * G√®re l‚Äôaudit log si non "trusted"

7. **Envoi de la r√©ponse**

   * En cas d‚Äôerreur : `ResponseToClient.sendError()` renvoie une erreur enrichie.
   * Sinon, copie de la r√©ponse vers le client.

8. **Nettoyage du contexte MDC**

---

## ‚öôÔ∏è Composants cl√©s

| Composant             | R√¥le                                                 |
| --------------------- | ---------------------------------------------------- |
| `PocFilter`           | Point d'entr√©e principal (`OncePerRequestFilter`)    |
| `ApiRequestFilter`    | Valide la requ√™te HTTP                               |
| `RequestValidator`    | V√©rifie URI, headers, m√©thode, corps, signature      |
| `RequestHandler`      | Traite la requ√™te m√©tier (`Accounts`, `Event`, etc.) |
| `ResponseFilter`      | Post-traitement de la r√©ponse HTTP                   |
| `ResponseHandler`     | Handler logique de r√©ponse                           |
| `ResponseToClient`    | Formatage et envoi de la r√©ponse HTTP ou erreur      |
| `FilterConfiguration` | Chargement des propri√©t√©s YAML de configuration      |
| `FilterLogHandler`    | Logging MDC avec `requestId`                         |

---

Souhaitez-vous que je g√©n√®re aussi une **version visuelle (image PNG/diagramme) du graphe ci-dessus** ou une **documentation structur√©e technique du filtre** ?
